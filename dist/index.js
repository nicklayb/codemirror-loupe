import { LRParser } from '@lezer/lr';
import { LRLanguage, indentNodeProp, foldNodeProp, foldInside, LanguageSupport } from '@codemirror/language';
import { styleTags, tags } from '@lezer/highlight';

// This file was generated by lezer-generator. You probably shouldn't edit it.
const spec_Identifier = {__proto__:null,all:22, where:48, in:104, like:110, empty:112};
const parser = LRParser.deserialize({
  version: 14,
  states: "-nOYQPOOOOQO'#C`'#C`O_QPO'#C_QOQPOOOjQPO'#CbOOQO'#Ch'#ChOxQPO,58yO!TQPO,58yOOQO'#Cb'#CbO!YQPO'#CdOOQO'#Cf'#CfOOQO,58|,58|O!_QPO,58|O!jQPO'#CiOOQO1G.e1G.eO!rQPO1G.eO!zQPO'#CsO#VQPO1G.eOOQO,59O,59OOOQO1G.h1G.hO#bQPO'#ClO#gQPO'#CkOOQO,59T,59TO#oQPO,59TOOQO7+$P7+$PO#tQQO'#DOO%dQPO'#C}O%kQPO'#C|O!zQPO'#CyO&]QPO'#CyOOQO'#Cx'#CxO&wQPO'#CxO'PQPO'#CwO'_QPO'#CvOOQO'#Cu'#CuOOQO,59_,59_O'jQPO7+$PO'rQPO,59WO(QQPO'#DgO(VQPO,59VOOQO1G.o1G.oOOQO'#DP'#DPO(_QPO'#DhO(dQQO,59jO)_QPO,59eO)gQPO'#DSOOQO,59i,59iO)lQPO,59iOOQO'#DV'#DVO*aQPO'#DjO*fQPO,59hO+WQPO,59eOOQO'#DY'#DYO'rQPO,59eO+]QPO,59eO+bQPO,59eOOQO'#Da'#DaOOQO'#Dd'#DdOOQO,59d,59dO!zQPO'#DlO+gQPO,59cO!zQPO'#DmO+uQPO,59bOOQO<<Gk<<GkOOQO'#Cn'#CnOOQO1G.r1G.rOOQO,5:R,5:ROOQO-E7e-E7eOOQO,5:S,5:SOOQO-E7f-E7fOOQO,59m,59mOOQO1G/P1G/PO,QQPO,59nOOQO1G/T1G/TO,YQPO'#C}OOQO,5:U,5:UOOQO-E7h-E7hO,aQPO'#DcOOQO,5:W,5:WOOQO-E7j-E7jOOQO,5:X,5:XOOQO-E7k-E7kO,rQPO'#DiO,wQPO1G/YOOQO1G/Y1G/YO-PQPO'#DROOQO,59},59}O-UQPO,59}OOQO,5:T,5:TOOQO-E7g-E7gOOQO7+$t7+$tO'rQPO'#DkO-^QPO1G/iOOQO1G/i1G/iOOQO,5:V,5:VOOQO-E7i-E7iOOQO7+%T7+%T",
  stateData: "-n~O!dOSPOS~OTPO~OTTOVSOZWO~OXXO!eYO!fYOTUX~O^]Oh`O!bRa~OTTO~OVbO~O!eYO!fYOTUa~OTdOffO~Oh`O!bRi~OTiOnlO!goO~O^]Oh`O!bRi~OauO~OevOf_X~OfxO~OtyOarXwrXzrX{rX}rX!OrX!PrX!QrX!RrX!SrX!UrX!XrX~Ow}OzqX{qX}qX!OqX!PqX!QqX!RqX!SqX!UqX!XqX~Oa|O~P$oOz!QO{!QO}pX!OpX!PpX!QpX!RpX!SpX!UpX!XpX~O}!UO!O!UO!P!UO!Q!UO!R!UO!S!UO!U!YO!X!ZO~OTiOnlO~O!h!]O!bkX!ikXokX~O!i!_O!bjXojX~Oh`O!bRq~OT!bOV!bOc!bOd!bO~OTdO~OevOf_a~OT!fO~OtyOarawrazra{ra}ra!Ora!Pra!Qra!Rra!Sra!Ura!Xra~OT!hO!Y!iO~OT!jO~Ow}Ozqa{qa}qa!Oqa!Pqa!Qqa!Rqa!Sqa!Uqa!Xqa~OTiO~Oz!QO{!QO}pa!Opa!Ppa!Qpa!Rpa!Spa!Upa!Xpa~Oo!iO~Ow!oO~Oc!iO~O!h!]O!bka!ikaoka~O!i!_O!bjaoja~Oe!tOx!vO~Oa!wO~P$oOT!bOV!bOc!bOd!bOx!xO~OT!zO~Oe!tOx!|O~OT!hO~Oe!}Ox#PO~Oe!}Ox#SO~Od!f!e!g!i!hT~",
  goto: "&n!bPPP!c!fP!iP!lP!oP!u!{P#R#UP#[PPPP#hP#r#x#|$T$]PP$f$m$w%RP%V%ZPP%bPP%fPPPPPP%iP%l%oPP%r%x&O&U&[&b&hRRORQORVQR[SQZSRc[QUQRaVQ_URtaRg]Qe]R!dvQ!cuQ!i!VQ!y!oR#Q!}Q^USh_aR!atQs`R!TlTr`lSq`lR!r!_Up`l!_R!p!]Wn`l!]!_R![oZm`lo!]!_Yk`lo!]!_R!m!RYj`lo!]!_R!l!RTzi{T!Pj!lS!Oj!lR!k!PT!Rk!SR!VmR!WmR!i!WR!XmQweR!ewQ{iR!g{Q!u!jR!{!uQ!SkR!n!SQ#O!yR#R#OQ!^pR!q!^Q!`qR!s!`",
  nodeNames: "âš  Comment Query Statement Command Identifier Quantifier Number Range .. Multiplier all Schema Parameters { ParameterList Parameter : Value String Boolean , } WhereClause where Predicate OrPredicate AndPredicate NotPredicate ComparisonPredicate ( ) FieldGroup FieldPath FieldPathBase PathSeparator . FieldVariant PathBinding [ ] GroupedOp | & ComparisonOp = != < > <= >= InOp in List LikeOp like empty",
  maxTerm: 71,
  skippedNodes: [0,1],
  repeatNodeCount: 7,
  tokenData: "2X~RuXY#fYZ#f]^#fpq#fqr#wrs$Sst%pvw&Xwx&^xy'uyz'z|}(P!O!P(U!Q![(c![!](k!^!_(p!_!`(}!`!a)S!c!})a!}#O)r#P#Q)w#R#S)a#T#U)|#U#Y)a#Y#Z+a#Z#_)a#_#`-q#`#a)a#a#b.U#b#c.i#c#d/|#d#h)a#h#i0x#i#o)a#o#p1x#p#q1}#q#r2S~#kS!d~XY#fYZ#f]^#fpq#f~#zP!_!`#}~$SO!O~~$VVOr$Srs$ls#O$S#O#P$q#P;'S$S;'S;=`%j<%lO$S~$qOc~~$tRO;'S$S;'S;=`$};=`O$S~%QWOr$Srs$ls#O$S#O#P$q#P;'S$S;'S;=`%j;=`<%l$S<%lO$S~%mP;=`<%l$S~%uSP~OY%pZ;'S%p;'S;=`&R<%lO%p~&UP;=`<%l%p~&^O{~~&aVOw&^wx$lx#O&^#O#P&v#P;'S&^;'S;=`'o<%lO&^~&yRO;'S&^;'S;=`'S;=`O&^~'VWOw&^wx$lx#O&^#O#P&v#P;'S&^;'S;=`'o;=`<%l&^<%lO&^~'rP;=`<%l&^~'zOn~~(POo~~(UOe~R(ZPtQ!O!P(^P(cOXP~(hPV~!Q![(c~(pOa~~(uP!P~!_!`(x~(}O!R~~)SO}~~)XP!Q~!_!`)[~)aO!S~~)fST~!Q![)a!c!})a#R#S)a#T#o)a~)wOw~~)|Ox~~*RUT~!Q![)a!c!})a#R#S)a#T#b)a#b#c*e#c#o)a~*jUT~!Q![)a!c!})a#R#S)a#T#W)a#W#X*|#X#o)a~+TS!h~T~!Q![)a!c!})a#R#S)a#T#o)a~+fTT~!Q![)a!c!})a#R#S)a#T#U+u#U#o)a~+zUT~!Q![)a!c!})a#R#S)a#T#`)a#`#a,^#a#o)a~,cUT~!Q![)a!c!})a#R#S)a#T#g)a#g#h,u#h#o)a~,zUT~!Q![)a!c!})a#R#S)a#T#X)a#X#Y-^#Y#o)a~-eSd~T~!Q![)a!c!})a#R#S)a#T#o)a~-xS!e~T~!Q![)a!c!})a#R#S)a#T#o)a~.]S!f~T~!Q![)a!c!})a#R#S)a#T#o)a~.nUT~!Q![)a!c!})a#R#S)a#T#c)a#c#d/Q#d#o)a~/VUT~!Q![)a!c!})a#R#S)a#T#h)a#h#i/i#i#o)a~/pS!g~T~!Q![)a!c!})a#R#S)a#T#o)a~0RUT~!Q![)a!c!})a#R#S)a#T#f)a#f#g0e#g#o)a~0lS!i~T~!Q![)a!c!})a#R#S)a#T#o)a~0}UT~!Q![)a!c!})a#R#S)a#T#f)a#f#g1a#g#o)a~1fUT~!Q![)a!c!})a#R#S)a#T#i)a#i#j,u#j#o)a~1}O^~~2SOz~~2XOf~",
  tokenizers: [0, 1],
  topRules: {"Query":[0,2]},
  specialized: [{term: 5, get: (value) => spec_Identifier[value] || -1}],
  tokenPrec: 574
});

const loupeHighlighting = styleTags({
    'where all in like empty and or not': tags.keyword,
    Command: tags.keyword,
    Identifier: tags.variableName,
    Schema: tags.typeName,
    String: tags.string,
    Number: tags.number,
    Boolean: tags.bool,
    Comment: tags.lineComment,
    'ComparisonOp InOp LikeOp': tags.compareOperator,
    'and or': tags.logicOperator,
    'not': tags.operatorKeyword,
    GroupedOp: tags.separator,
    '( )': tags.paren,
    '[ ]': tags.squareBracket,
    '{ }': tags.brace,
    ':': tags.punctuation,
    ',': tags.separator,
    '.': tags.derefOperator,
    '..': tags.operator,
    '|': tags.separator,
    '&': tags.separator,
    'multiplierK multiplierM': tags.unit,
    FieldVariant: tags.modifier,
    PathBinding: tags.special(tags.propertyName)
});

const KEYWORDS = [
    { label: 'where', type: 'keyword', info: 'Filter condition', detail: undefined },
    { label: 'and', type: 'keyword', info: 'Logical AND', detail: undefined },
    { label: 'or', type: 'keyword', info: 'Logical OR', detail: undefined },
    { label: 'not', type: 'keyword', info: 'Logical NOT', detail: undefined },
    { label: 'in', type: 'keyword', info: 'Check if value is in list', detail: undefined },
    { label: 'like', type: 'keyword', info: 'Pattern matching', detail: undefined },
    { label: 'empty', type: 'keyword', info: 'Check if field is empty', detail: undefined },
    { label: 'all', type: 'keyword', info: 'Get all records', detail: undefined }
];
const OPERATORS = [
    { label: '=', type: 'operator', info: 'Equal', detail: undefined },
    { label: '!=', type: 'operator', info: 'Not equal', detail: undefined },
    { label: '>', type: 'operator', info: 'Greater than', detail: undefined },
    { label: '<', type: 'operator', info: 'Less than', detail: undefined },
    { label: '>=', type: 'operator', info: 'Greater than or equal', detail: undefined },
    { label: '<=', type: 'operator', info: 'Less than or equal', detail: undefined }
];
class MissingRequiredSchema extends Error {
    constructor() {
        super("Expected schema to be read, found none");
        this.name = 'MissingRequiredSchema';
    }
}
class Matcher {
    constructor(config, context) {
        this.schemaName = null;
        const { state, pos } = context;
        this.config = config;
        this.position = pos;
        this.textBefore = state.doc.sliceString(0, pos);
        this.line = state.doc.lineAt(pos);
        this.lineText = this.line.text;
        this.cursorInLine = pos - this.line.from;
        this.textBeforeInLine = this.lineText.slice(0, this.cursorInLine);
    }
    extractSchema() {
        const lines = this.textBefore.split('\n');
        for (let i = lines.length - 1; i >= 0; i--) {
            const line = lines.slice(0, i + 1).join('\n');
            const match = line.match(/\b(\w+)\s+(?:\d+\.\.\d+|\d+[km]?|all)?\s*(\w+)(?:\s+\{.*?\})?\s+where\b/);
            if (match) {
                return match[2];
            }
            const simpleMatch = line.match(/\b(\w+)\s+(?:\d+\.\.\d+|\d+[km]?|all)?\s*(\w+)\s*$/);
            if (simpleMatch && i === lines.length - 1) {
                return simpleMatch[2];
            }
        }
        return null;
    }
    async listCommands() {
        if (/^\s*$/.test(this.textBeforeInLine) || /^\s*\w*$/.test(this.textBeforeInLine)) {
            const commands = await this.config.getCommands();
            return {
                from: this.position - (this.textBeforeInLine.match(/\w+$/)?.[0].length || 0),
                options: commands,
                validFor: /^\w*$/
            };
        }
    }
    async listSchemas() {
        const commandMatch = this.textBeforeInLine.match(/^(\w+)\s+(?:\d+\.\.\d+|\d+[km]?|all)?\s*(\w*)$/);
        if (commandMatch) {
            const command = commandMatch[1];
            const partial = commandMatch[2];
            const schemas = await this.config.getSchemas(command);
            return {
                from: this.position - partial.length,
                options: schemas,
                validFor: /^\w*$/
            };
        }
    }
    async listNestedFields() {
        this.schemaName = this.extractSchema();
        if (!this.schemaName) {
            throw new MissingRequiredSchema();
        }
        const fieldPathMatch = this.textBeforeInLine.match(/([\w.]+)\.(\w*)$/);
        if (fieldPathMatch && this.schemaName) {
            const fullPath = fieldPathMatch[1];
            const partial = fieldPathMatch[2];
            const fieldPath = fullPath.split('.');
            const fields = await this.config.getFields({
                schema: this.schemaName,
                fieldPath,
                type: 'field'
            });
            return {
                from: this.position - partial.length,
                options: fields,
                validFor: /^[\w]*$/
            };
        }
    }
    async listFields() {
        if (/\bwhere\s+(\w*)$/.test(this.textBeforeInLine) && this.schemaName) {
            const partial = this.textBeforeInLine.match(/\bwhere\s+(\w*)$/)?.[1] || '';
            const fields = await this.config.getFields({
                schema: this.schemaName,
                fieldPath: [],
                type: 'field'
            });
            return {
                from: this.position - partial.length,
                options: fields,
                validFor: /^[\w]*$/
            };
        }
    }
    async listKeywordOperators() {
        const afterLogicMatch = this.textBeforeInLine.match(/(?:and|or|\()\s+([\w.]*)$/);
        if (afterLogicMatch && this.schemaName) {
            const pathText = afterLogicMatch[1];
            const partial = pathText.split('.').pop() || '';
            const pathParts = pathText.split('.');
            pathParts.pop();
            const fields = await this.config.getFields({
                schema: this.schemaName,
                fieldPath: pathParts.filter((part) => part.length > 0),
                type: 'field'
            });
            const allOptions = [...fields, ...KEYWORDS.filter(keyword => ['not'].includes(keyword.label))];
            return {
                from: this.position - partial.length,
                options: allOptions,
                validFor: /^[\w]*$/
            };
        }
    }
    async listOperators() {
        const afterFieldMatch = this.textBeforeInLine.match(/\b([\w.]+)\s+(\S*)$/);
        if (afterFieldMatch && !['where', 'and', 'or', 'not', 'in', 'like', 'all'].includes(afterFieldMatch[1])) {
            const partial = afterFieldMatch[2];
            return {
                from: this.position - partial.length,
                options: [
                    ...OPERATORS,
                    { label: 'in', type: 'keyword', info: 'Check if value is in list', detail: undefined },
                    { label: 'like', type: 'keyword', info: 'Pattern matching', detail: undefined }
                ],
                validFor: /^[=!<>]*$/
            };
        }
    }
    async listKeywords() {
        if (/\bwhere\b/.test(this.textBefore)) {
            const partial = this.textBeforeInLine.match(/\w+$/)?.[0] || '';
            return {
                from: this.position - partial.length,
                options: KEYWORDS.filter(k => !['all'].includes(k.label)),
                validFor: /^\w*$/
            };
        }
    }
    async getCompletion() {
        const RULES = [
            this.listCommands.bind(this),
            this.listSchemas.bind(this),
            this.listNestedFields.bind(this),
            this.listFields.bind(this),
            this.listKeywordOperators.bind(this),
            this.listOperators.bind(this),
            this.listKeywords.bind(this),
        ];
        for (const rule of RULES) {
            try {
                const match = await rule();
                if (match) {
                    return match;
                }
            }
            catch (error) {
                if (error instanceof MissingRequiredSchema) {
                    return null;
                }
                throw error;
            }
        }
        return null;
    }
}
function loupeCompletion(config) {
    return async (context) => {
        const matcher = new Matcher(config, context);
        return await matcher.getCompletion();
    };
}

const loupeLanguage = LRLanguage.define({
    name: 'loupe',
    parser: parser.configure({
        props: [
            indentNodeProp.add({
                Query: () => 0,
                Parameters: (context) => context.baseIndent + context.unit,
                List: (context) => context.baseIndent + context.unit
            }),
            foldNodeProp.add({
                Parameters: foldInside,
                List: foldInside,
                WhereClause: foldInside
            }),
            loupeHighlighting
        ]
    }),
});
/**
 * Loupe language support extension for CodeMirror.
 *
 * @returns A LanguageSupport instance for the Loupe query language
 *
 * @example
 * ```typescript
 * import { EditorView, basicSetup } from 'codemirror';
 * import { loupe } from '@nicklayb/codemirror-lang-loupe';
 *
 * new EditorView({
 *   doc: 'get User where email = "user@example.com"',
 *   extensions: [basicSetup, loupe()],
 *   parent: document.querySelector('#editor')
 * });
 * ```
 */
function loupe() {
    return new LanguageSupport(loupeLanguage);
}

export { loupe, loupeCompletion, loupeLanguage };
//# sourceMappingURL=index.js.map
